// Generated by CoffeeScript 1.6.3
(function() {
  var async, concatStream, fileToFile_globsToDirWithOptionalWatch, fs, glob, mkdirp, path, stringFun_fileFun, watchGlob, _;

  _ = require('lodash');

  async = require('async');

  fs = require('fs');

  path = require('path');

  glob = require('glob');

  watchGlob = require('watch-glob');

  mkdirp = require('mkdirp');

  concatStream = require('concat-stream');

  exports.sync_async = function(f) {
    return function() {
      var args, callback;
      args = Array.prototype.slice.call(arguments);
      callback = _.isFunction(_.last(args)) ? _.last(args) : (function() {});
      return async.nextTick(function() {
        var e, result;
        try {
          result = f.apply(null, args);
          return callback(null, result);
        } catch (_error) {
          e = _error;
          return callback(e);
        }
      });
    };
  };

  stringFun_fileFun = function(receivesMultipleInputs, f, oldInputIndex, newOutputFilePathIndex) {
    if (oldInputIndex == null) {
      oldInputIndex = 0;
    }
    if (newOutputFilePathIndex == null) {
      newOutputFilePathIndex = 1;
    }
    return function() {
      var args, callback, callbackIndex, inFiles, inputIndex, outFile;
      args = Array.prototype.slice.call(arguments);
      inputIndex = newOutputFilePathIndex <= oldInputIndex ? oldInputIndex + 1 : oldInputIndex;
      callbackIndex = Math.max(args.length - 1, 2);
      callback = _.isFunction(args[callbackIndex]) ? args[callbackIndex] : (function() {});
      inFiles = receivesMultipleInputs ? args[inputIndex] : [args[inputIndex]];
      outFile = args[newOutputFilePathIndex];
      args[callbackIndex] = function(err, result) {
        return mkdirp(path.dirname(outFile), function(err, createdDir) {
          if (err) {
            return callback(err);
          }
          return fs.writeFile(outFile, result, null, function(err) {
            if (err) {
              return callback(err);
            }
            return callback(null, outFile);
          });
        });
      };
      return async.map(inFiles, (function(f, cb) {
        return fs.readFile(f, {
          encoding: 'utf-8'
        }, cb);
      }), function(err, fileContents) {
        if (err != null) {
          return callback(err);
        }
        args[inputIndex] = receivesMultipleInputs ? fileContents : fileContents[0];
        args.splice(newOutputFilePathIndex, 1);
        return f.apply(null, args);
      });
    };
  };

  exports.stringToString_fileToFile = function(f, oldInputIndex, newOutputFilePathIndex) {
    if (oldInputIndex == null) {
      oldInputIndex = 0;
    }
    if (newOutputFilePathIndex == null) {
      newOutputFilePathIndex = 1;
    }
    return stringFun_fileFun(false, f, oldInputIndex, newOutputFilePathIndex);
  };

  exports.stringsToString_filesToFile = function(f, oldInputIndex, newOutputFilePathIndex) {
    if (oldInputIndex == null) {
      oldInputIndex = 0;
    }
    if (newOutputFilePathIndex == null) {
      newOutputFilePathIndex = 1;
    }
    return stringFun_fileFun(true, f, oldInputIndex, newOutputFilePathIndex);
  };

  fileToFile_globsToDirWithOptionalWatch = function(f, extension, withWatch, oldInputIndex, oldOutputIndex, newGlobOptionsIndex) {
    if (withWatch == null) {
      withWatch = false;
    }
    if (oldInputIndex == null) {
      oldInputIndex = 0;
    }
    if (oldOutputIndex == null) {
      oldOutputIndex = 1;
    }
    if (newGlobOptionsIndex == null) {
      newGlobOptionsIndex = 1;
    }
    return function() {
      var args, callback, callbackIndex, globOptions, inputIndex, outputDir, outputFilePath, outputIndex, patterns;
      args = Array.prototype.slice.call(arguments);
      inputIndex = newGlobOptionsIndex <= oldInputIndex ? oldInputIndex + 1 : oldInputIndex;
      outputIndex = newGlobOptionsIndex <= oldOutputIndex ? oldOutputIndex + 1 : oldOutputIndex;
      callbackIndex = Math.max(args.length - (withWatch ? 3 : 1), 3);
      callback = _.isFunction(args[callbackIndex]) ? args[callbackIndex] : (function() {});
      patterns = _.isArray(args[inputIndex]) ? args[inputIndex] : [args[inputIndex]];
      globOptions = args[newGlobOptionsIndex];
      outputDir = args[outputIndex];
      outputFilePath = function(p) {
        var outPath;
        outPath = path.normalize(path.resolve(p)) === path.normalize(p) ? path.join(outputDir, path.basename(p)) : path.join(outputDir, p);
        if ((extension != null ? extension.length : void 0) > 0) {
          return "" + outPath + "." + extension;
        } else {
          return outPath;
        }
      };
      return async.map(patterns, (function(pattern, cb) {
        return glob(pattern, globOptions, cb);
      }), function(err, matches) {
        var allMatches, inFilesAbsolute, outFiles, processFilePair;
        allMatches = _(matches).flatten().uniq().value();
        inFilesAbsolute = _.map(allMatches, function(p) {
          return path.resolve((globOptions != null ? globOptions.cwd : void 0) || '', p);
        });
        outFiles = _.map(allMatches, outputFilePath);
        processFilePair = function(filePair, cb) {
          var callArgs;
          callArgs = _.clone(args);
          callArgs[inputIndex] = filePair[0];
          callArgs[outputIndex] = filePair[1];
          callArgs[callbackIndex] = cb;
          callArgs = callArgs.slice(0, callbackIndex + 1);
          callArgs.splice(newGlobOptionsIndex, 1);
          return f.apply(null, callArgs);
        };
        return async.map(_.zip(inFilesAbsolute, outFiles), processFilePair, function(err, success) {
          var buildFile, deleteFile, removeCallback, removeCallbackIndex, updateCallback, updateCallbackIndex;
          if (err) {
            return callback(err);
          } else if (!withWatch) {
            return callback(err, success);
          } else {
            updateCallbackIndex = Math.max(args.length - 2, 4);
            removeCallbackIndex = Math.max(args.length - 1, 5);
            updateCallback = args[updateCallbackIndex] || (function() {});
            removeCallback = args[removeCallbackIndex] || (function() {});
            buildFile = function(file) {
              return processFilePair([file.path, outputFilePath(file.relative)], updateCallback);
            };
            deleteFile = function(file) {
              var builtPath;
              builtPath = outputFilePath(file.relative);
              return fs.unlink(builtPath, function(err, success) {
                return removeCallback(err, builtPath);
              });
            };
            watchGlob(patterns, globOptions, buildFile, deleteFile);
            return callback(err, success);
          }
        });
      });
    };
  };

  exports.fileToFile_globsToDir = function(f, extension, oldInputIndex, oldOutputIndex, newGlobOptionsIndex) {
    if (oldInputIndex == null) {
      oldInputIndex = 0;
    }
    if (oldOutputIndex == null) {
      oldOutputIndex = 1;
    }
    if (newGlobOptionsIndex == null) {
      newGlobOptionsIndex = 1;
    }
    return fileToFile_globsToDirWithOptionalWatch(f, extension, false, oldInputIndex, oldOutputIndex, newGlobOptionsIndex);
  };

  exports.fileToFile_globsToDirWithWatch = function(f, extension, oldInputIndex, oldOutputIndex, newGlobOptionsIndex) {
    if (oldInputIndex == null) {
      oldInputIndex = 0;
    }
    if (oldOutputIndex == null) {
      oldOutputIndex = 1;
    }
    if (newGlobOptionsIndex == null) {
      newGlobOptionsIndex = 1;
    }
    return fileToFile_globsToDirWithOptionalWatch(f, extension, true, oldInputIndex, oldOutputIndex, newGlobOptionsIndex);
  };

  exports.filesToFile_globsToFile = function(f, oldInputIndex, oldOutputIndex, newGlobOptionsIndex) {
    if (oldInputIndex == null) {
      oldInputIndex = 0;
    }
    if (oldOutputIndex == null) {
      oldOutputIndex = 1;
    }
    if (newGlobOptionsIndex == null) {
      newGlobOptionsIndex = 1;
    }
    return function() {
      var args, callback, callbackIndex, globOptions, inputIndex, outputFile, outputIndex, patterns;
      args = Array.prototype.slice.call(arguments);
      inputIndex = newGlobOptionsIndex <= oldInputIndex ? oldInputIndex + 1 : oldInputIndex;
      outputIndex = newGlobOptionsIndex <= oldOutputIndex ? oldOutputIndex + 1 : oldOutputIndex;
      callbackIndex = Math.max(args.length - 1, 3);
      callback = _.isFunction(args[callbackIndex]) ? args[callbackIndex] : (function() {});
      patterns = _.isArray(args[inputIndex]) ? args[inputIndex] : [args[inputIndex]];
      globOptions = args[newGlobOptionsIndex];
      outputFile = args[outputIndex];
      return async.map(patterns, (function(pattern, cb) {
        return glob(pattern, globOptions, cb);
      }), function(err, matches) {
        var allMatches, inFilesAbsolute;
        allMatches = _(matches).flatten().uniq().value();
        inFilesAbsolute = _.map(allMatches, function(p) {
          return path.resolve((globOptions != null ? globOptions.cwd : void 0) || '', p);
        });
        args[inputIndex] = inFilesAbsolute;
        args.splice(newGlobOptionsIndex, 1);
        return f.apply(null, args);
      });
    };
  };

  exports.transformStream_stringToString = function(transformStreamConstructor) {
    return function(inputString, callback) {
      var gotError, s, w;
      if (callback == null) {
        callback = (function() {});
      }
      gotError = false;
      s = transformStreamConstructor();
      w = concatStream({
        encoding: 'string'
      }, function(data) {
        if (!gotError) {
          return callback(null, data);
        }
      });
      s.on('error', function(err) {
        gotError = true;
        return callback(err);
      });
      s.pipe(w);
      s.write(inputString);
      return s.end();
    };
  };

  exports.transformStream_fileToFile = function(transformStreamConstructor) {
    return function(inputFile, outFile, callback) {
      var gotError, s;
      if (callback == null) {
        callback = (function() {});
      }
      gotError = false;
      s = transformStreamConstructor();
      return mkdirp(path.dirname(outFile), function(err, createdDir) {
        var handleError, readStream, stream, writeStream;
        readStream = fs.createReadStream(inputFile, {
          encoding: 'utf-8'
        });
        writeStream = fs.createWriteStream(outFile);
        stream = readStream.pipe(s).pipe(writeStream);
        stream.on('finish', function() {
          if (!gotError) {
            return callback(null, outFile);
          }
        });
        handleError = function(err) {
          gotError = true;
          writeStream.end();
          return callback(err);
        };
        readStream.on('error', handleError);
        return s.on('error', handleError);
      });
    };
  };

  exports.transformStream_globsToDir = function(transformStreamConstructor, ext) {
    var fileToFile;
    fileToFile = exports.transformStream_fileToFile(transformStreamConstructor);
    return exports.fileToFile_globsToDir(fileToFile, ext);
  };

  exports.stringToString_globsToDir = function(f, ext, inputIndex) {
    var fileToFile;
    if (inputIndex == null) {
      inputIndex = 0;
    }
    fileToFile = exports.stringToString_fileToFile(f, inputIndex);
    return exports.fileToFile_globsToDir(fileToFile, ext, inputIndex);
  };

  exports.stringToString_globsToDirWithWatch = function(f, ext, inputIndex) {
    var fileToFile;
    if (inputIndex == null) {
      inputIndex = 0;
    }
    fileToFile = exports.stringToString_fileToFile(f, inputIndex);
    return exports.fileToFile_globsToDirWithWatch(fileToFile, ext, inputIndex);
  };

  exports.sync_fileToFile = function(f, inputIndex) {
    if (inputIndex == null) {
      inputIndex = 0;
    }
    return exports.stringToString_fileToFile(exports.sync_async(f), inputIndex);
  };

  exports.sync_globsToDir = function(f, extension, inputIndex) {
    if (inputIndex == null) {
      inputIndex = 0;
    }
    return exports.stringToString_globsToDir(exports.sync_async(f), extension, inputIndex);
  };

  exports.sync_globsToDirWithWatch = function(f, extension, inputIndex) {
    if (inputIndex == null) {
      inputIndex = 0;
    }
    return exports.stringToString_globsToDirWithWatch(exports.sync_async(f), extension, inputIndex);
  };

  exports.stringsToString_globsToFile = function(f, inputIndex) {
    var fileToFile;
    if (inputIndex == null) {
      inputIndex = 0;
    }
    fileToFile = exports.stringsToString_filesToFile(f, inputIndex);
    return exports.filesToFile_globsToFile(fileToFile, inputIndex);
  };

  exports.sync_filesToFile = function(f, inputIndex) {
    if (inputIndex == null) {
      inputIndex = 0;
    }
    return exports.stringsToString_filesToFile(exports.sync_async(f), inputIndex);
  };

  exports.sync_globsToFile = function(f, inputIndex) {
    if (inputIndex == null) {
      inputIndex = 0;
    }
    return exports.stringsToString_globsToFile(exports.sync_async(f), inputIndex);
  };

}).call(this);
